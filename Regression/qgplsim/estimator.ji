module qglsim
using Optim, LinearAlgebra, Distributions, Random, Statistics

function Base.:-(X::Matrix, xi::Vector)
    n, p = size(X)
    for i in 1:n
        X[i, :] = X[i, :] - xi
    end
    X
end

function collection(c::Array{Int, 2})
    n, p = size(c)
    categ_c = []
    dict_c = Dict()
    for i in 1:n
        if c[i, :] in categ_c
            push!(dict_c[c[i, :]], i)
        else
            push!(categ_c, c[i, :])
            dict_c[c[i, :]] = [i]
        end
    end
    categ_c, dict_c
end

distribution_ker = Normal(0, 1)

function ker(x)
    pdf(distribution_ker, x)
end

function ker(x::Vector, h::Vector)
    d = length(x)
    v = 1
    for i in 1:d 
        v *= ker(x[i]/h[i])
    end
    v
end

function ker(x::Matrix, xi::Vector, h::Vector)
    n, p = size(x)
    v = zeros(n)
    for i in 1:n
        v[i] = ker(x[i, :] - xi, h)
    end
    v
end

ρ(x, α = 0.5) = abs(x) + (2α - 1)x

function optimfunc(f, init_value, tols = 1e-5)
    res = optimize(f, init_value, method=BFGS(), f_tol=tols)
    return res 
end


function alphatheta_estimator(X, Z, y)
	n, p = size(X)
	α, θ = zeros(p), zeros(p)
	h = ones(p) .* 0.3
	categ, index = collection(Z)

	for z in categ
		nz = length(index[z])
		az = zeros(nz)
		bz = zeros(nz, p)
		w0 = zeros(p + 1)
		yz = y[index[z]]
		Xz = X[index[z], :]
		for i in 1:nz

			tarfunc(w) = sum(ρ.(yz .- w[1] .- sum((Xz - Xz[i, :]) * w[2:end])) .* ker(Xz,  Xz[i, :], h))
			res = optimfunc(tarfunc, w0)
			wi = res.minimizer
			az[i] = wi[1]
			bz[i,:] = wi[2:end]

		end

		αz = zeros(p)
		sum_bz = zeros(p)
		for i in 1:nz - 1
			for j in i + 1:nz
				sum_bz += bz[i, :] - bz[j, :]
			end
		end
		norm_bz = norm(sum_bz)
		αz = sum_bz/norm_bz
		α += αz * nz / n
	end
	α, θ

end


function estimator_theta()

end

function estimator_beta()

end

function estimator_gamma()

end
end