include("../src/twoStageQR.ji")
include("../src/StructClassifier.ji")

function generate_model(trainData, q = 0.5, pbs = 3, nbs = 4)
	knots = [-4., -3., -2., 0., 2., 3., 4.]./2 # ./2 .+ 0.5
	elems = additiveQR.bsplElems(pbs, nbs)
	# elems = additiveQR.bsplElems(knots, pbs)
	model1 = additiveQR.model(elems, trainData, q, true)
end

function main(orderPoly = 3)
	
	var = 1
	eta = 0.
	q = 0.5
	nTrain = 180
	nTest = 20
	dSamples = 3
	d_zeros = 1
	err_type = "g"
	trainData1 = additiveQR.data(nTrain, dSamples, d_zeros, var, eta, err_type)
	testData1 = additiveQR.data(nTest, dSamples, d_zeros, var, eta, err_type)	
	# f = open("record.txt", "w")
	# close(f)
	# @threads for k in 1:4
	Lambda = Dict()
	ind = Int.(ones(dSamples + d_zeros))
	for k in 1:orderPoly
		model1 = generate_model(trainData1, q)
		res1 = strucRec(model1, testData1, k, 10.0, 32*k)
		lambda = res1["lambda"]
		# bic0 = nTest * log(additiveQR.SAE(model1, testData1, lambda, k)) + 2*length(lambda)*log(nTest)
		# println("bic0: ", bic0)
		# bic1 = copy(bic0) 
		# while bic1 <= bic0 && length(lambda) > 1
			Xtr, ytr = trainData1.X, trainData1.y
			Xte, yte = testData1.X, testData1.y
			# bic0 = copy(bic1)
			p = length(lambda)
			indl = lambda .> sum(lambda)/(4p)
			lambda_ = lambda[indl]
			println(lambda_)
			trainData2 = additiveQR.data(Xtr[:, indl], ytr)
			testData2 = additiveQR.data(Xte[:, indl], yte)
			# model2 = generate_model(trainData2, q)
			# bic1 = nTest * log(additiveQR.SAE(model2, testData2, lambda_, k)) + 2*p*log(nTest)
			# println("bic1: ", bic1, "\n", "index: ", indl)
			# if bic1 < bic0
				lambda = copy(lambda_)
				ind = copy(indl)
				testData1, trainData1 = deepcopy(testData2), deepcopy(trainData2)
				# println(k)
			# end
		# end
		Lambda[k] = [lambda, ind]

	end
	#     f = open("record.txt", "a")
	# 	println(f, res1, "\n")
	#     close(f)
	# end
	Lambda
	# sae(l) = additiveQR.SAE(model1, l, 1)
end