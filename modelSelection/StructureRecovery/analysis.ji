function L2Error(y1, y2)
    sum((y1 - y2).^2)/length(y1)
end

function QBIC(pbs, nSamples)
    minkn = pbs + 1
    println("Sample size is $nSamples \n")
    trainData = additiveQR.data_set3d(nSamples)
    for kn in minkn:minkn + 3
        elem = additiveQR.bsplElems(pbs, kn)
        model = additiveQR.twoStageAddQR(elem, trainData, 0.5)
        println("QBIC(nBasis = $kn, pBasis = $pbs) is $(model.qbic) \n")
    end
end

# qbic = n*log(n*res.minimum) + 2log(n)*nBasis

function BIC(Lambda, model, ∇ = 1)
    nstep, dim = size(Lambda)
    n = length(model.trainData.y)   
    Ind = zeros(nstep, dim) 
    sae = zeros(nstep)
    
    tau = sum(Lambda, dims = 2)
    tau = tau[:,1]
    threshold = tau ./ (4*dim)

    ord_tau = zeros(nstep)
    for k in (1:nstep)
        Ind[k, :] = Lambda[k, :] .> threshold[k]
        ord_tau[k] = sum(Ind[k, :])
    end    
    
    for k in 1:nstep
        lambda = Lambda[k, :] .* Ind[k,:]
        ind = lambda .> 0
        x = model.trainData.X[:, ind]
        lambda = lambda[ind]
        sae[k] = additiveQR.SAE(model, lambda, x, model.trainData.y, ∇)
    end

    bic = n * log.(sae)  + 2ord_tau * log(n) 
    ind = argmin(bic)
    res = Dict("sae" => sae, "bic" => bic, "ord" => ord_tau, "ind" => ind)

end




function qBIC(λ::Array{Float64, 1}, model, ∇)
    dim = length(λ)
    n = length(model.trainData.y)
    bic(s, p) = n * log(s) + 2p * log(n) # qbic
#     bic(s, p) = n * log(s/n) + p * log(n)/2 # sic
    sae(λ, Ind) = additiveQR.SAE(model, λ, model.trainData.X[:, Ind], model.trainData.y, ∇)

    Ind = λ .> 0

    s0 = sae(λ, Ind)
    p0 = sum(Ind)
    sk = s0 - 0.01
    pk = p0
    Indk = copy(Ind)
    λk = copy(λ)
    λ_temp = copy(λ)
    while bic(sk, pk) < bic(s0, p0)
        s0 = sk
        p0 = pk
        Ind = copy(Indk)

        ind = argmin(λ_temp)
        λ_temp[ind] = 1e7
        Indk[ind] = 0
        pk = sum(Indk)
        λk = λ[Indk]
        sk = sae(λk, Indk)

    end
    Ind, bic(s0, p0)

end
